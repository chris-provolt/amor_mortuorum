from __future__ import annotations

import logging
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Set

logger = logging.getLogger(__name__)


@dataclass
class Room:
    """Represents a room on a floor. This is a simplified placeholder.

    Integration points:
    - Actual dungeon generator should create Rooms with spatial data.
    - Room 'kind' can be used to drive encounter generation & visuals.
    """

    id: int
    kind: str = "normal"  # examples: normal, chest, trap, miniboss, boss
    metadata: Dict[str, object] = field(default_factory=dict)


@dataclass
class Stairs:
    """Represents the floor's stairs/downward exit with lock semantics.

    Locking supports multiple reasons, and remains locked while at least one
    reason is active. This avoids trampling other systems' locks.
    """

    lock_reasons: Set[str] = field(default_factory=set)

    @property
    def locked(self) -> bool:
        return len(self.lock_reasons) > 0

    def lock(self, reason: str) -> None:
        if reason not in self.lock_reasons:
            self.lock_reasons.add(reason)
            logger.debug("Stairs locked (reason=%s). All reasons=%s", reason, self.lock_reasons)

    def unlock_reason(self, reason: str) -> None:
        if reason in self.lock_reasons:
            self.lock_reasons.remove(reason)
            logger.debug(
                "Removed lock reason=%s from stairs. Remaining reasons=%s", reason, self.lock_reasons
            )

    def clear_all_locks(self) -> None:
        self.lock_reasons.clear()
        logger.debug("Cleared all lock reasons from stairs")


@dataclass
class Floor:
    """Represents a dungeon floor. This is a simplified model suitable for tests
    and as an integration facade for the Miniboss Gate system.

    Production integration notes:
    - depth: 1..99 (B1..B99); used to determine miniboss gates.
    - rooms: Generated by BSP or other algorithm.
    - stairs: Should correspond to the tile/entity in the map that leads downwards.
    - metadata: Arbitrary flags that other systems can read.
    """

    depth: int
    rooms: List[Room] = field(default_factory=list)
    stairs: Stairs = field(default_factory=Stairs)
    metadata: Dict[str, object] = field(default_factory=dict)

    def add_room(self, kind: str, **metadata: object) -> Room:
        room_id = len(self.rooms) + 1
        room = Room(id=room_id, kind=kind, metadata=metadata)
        self.rooms.append(room)
        logger.debug("Added room id=%s kind=%s metadata=%s", room_id, kind, metadata)
        return room

    def get_first_room_by_kind(self, kind: str) -> Optional[Room]:
        return next((r for r in self.rooms if r.kind == kind), None)

    def set_flag(self, key: str, value: object = True) -> None:
        self.metadata[key] = value
        logger.debug("Set floor flag %s=%s", key, value)

    def get_flag(self, key: str, default: object = None) -> object:
        return self.metadata.get(key, default)
