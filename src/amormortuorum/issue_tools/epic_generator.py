import logging
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple

import yaml

from .github_client import GitHubClient


@dataclass
class IssueDef:
    key: str
    title: str
    body: Optional[str] = None
    labels: Optional[List[str]] = None
    assignees: Optional[List[str]] = None
    milestone: Optional[int] = None


@dataclass
class EpicDef:
    title: str
    body: Optional[str] = None
    labels: Optional[List[str]] = None
    target_window: Optional[str] = None


@dataclass
class EpicConfig:
    epic: EpicDef
    children: List[IssueDef]


class EpicGenerator:
    """Creates an Epic issue and child issues in GitHub from a YAML configuration.

    The generator:
      - Ensures labels exist (including 'epic')
      - Creates child issues if they do not already exist (title match)
      - Creates the epic issue with an auto-generated checklist linking child issues
      - Posts cross-link comments on both epic and children
    """

    def __init__(self, client: GitHubClient) -> None:
        self.client = client
        self._log = logging.getLogger(self.__class__.__name__)

    @staticmethod
    def load_config(path: str) -> EpicConfig:
        with open(path, "r", encoding="utf-8") as f:
            raw = yaml.safe_load(f)
        epic_raw = raw.get("epic") or {}
        epic = EpicDef(
            title=epic_raw["title"],
            body=epic_raw.get("body"),
            labels=epic_raw.get("labels") or ["epic"],
            target_window=epic_raw.get("target_window"),
        )
        children: List[IssueDef] = []
        for it in raw.get("children", []):
            children.append(
                IssueDef(
                    key=it["key"],
                    title=it["title"],
                    body=it.get("body"),
                    labels=it.get("labels") or [],
                    assignees=it.get("assignees"),
                    milestone=it.get("milestone"),
                )
            )
        return EpicConfig(epic=epic, children=children)

    @staticmethod
    def _default_epic_body(epic: EpicDef, children: List[Tuple[IssueDef, Optional[int]]]) -> str:
        lines: List[str] = []
        lines.append(f"## Summary\n{epic.title}\n")
        if epic.target_window:
            lines.append(f"**Target Window:** {epic.target_window}\n")
        lines.append("\n## Acceptance\n- Child issues exist and are linked in comments.\n- Labels applied: `epic`.\n- Progress can be tracked via linked issues checklist.\n")
        lines.append("\n## Checklist\n")
        for child, num in children:
            if num:
                lines.append(f"- [ ] {child.title} (#{num})")
            else:
                lines.append(f"- [ ] {child.title}")
        lines.append("\n---\n\nAuto-generated by epic generator.")
        return "\n".join(lines)

    def _collect_all_labels(self, cfg: EpicConfig) -> List[str]:
        labels = set(cfg.epic.labels or [])
        for c in cfg.children:
            for l in (c.labels or []):
                labels.add(l)
        return sorted(labels)

    def _ensure_labels(self, cfg: EpicConfig) -> None:
        # Ensure the 'epic' label exists with a distinct color if used
        all_labels = self._collect_all_labels(cfg)
        for label in all_labels:
            desc = "Epic tracker" if label.lower() == "epic" else None
            self.client.ensure_label(label, color="5319e7" if label.lower() == "epic" else "0e8a16", description=desc)

    def _create_or_find_child(self, child: IssueDef) -> Tuple[IssueDef, int, bool]:
        """Returns (child, issue_number, created_flag)."""
        existing = self.client.search_issue_by_title(child.title)
        if existing:
            num = int(existing["number"])
            self._log.info("Found existing child issue #%s for '%s'", num, child.title)
            return (child, num, False)
        labels = child.labels or []
        res = self.client.create_issue(title=child.title, body=child.body, labels=labels, assignees=child.assignees, milestone=child.milestone)
        return (child, int(res["number"]), True)

    def generate(self, cfg: EpicConfig, dry_run: bool = False) -> Dict:
        """Generate the epic and child issues.

        Returns a summary dict with epic number, child mapping, and URLs.
        """
        self._ensure_labels(cfg)

        created_children: List[Tuple[IssueDef, int, bool]] = []
        for child in cfg.children:
            if dry_run:
                created_children.append((child, 0, True))
            else:
                created_children.append(self._create_or_find_child(child))

        # Build the epic body with dynamic checklist including child issue numbers
        numbered_children: List[Tuple[IssueDef, Optional[int]]] = [
            (c, num if num != 0 else None) for (c, num, _created) in created_children
        ]
        epic_body = cfg.epic.body or self._default_epic_body(cfg.epic, numbered_children)

        if dry_run:
            return {
                "epic": {"title": cfg.epic.title, "labels": cfg.epic.labels or ["epic"], "body": epic_body},
                "children": [
                    {"title": c.title, "labels": c.labels or [], "body": c.body} for (c, _num, _cr) in created_children
                ],
                "links": [],
            }

        # Create epic issue (or find existing by exact title)
        existing_epic = self.client.search_issue_by_title(cfg.epic.title)
        if existing_epic:
            epic_number = int(existing_epic["number"])
            self._log.info("Updating existing epic #%s", epic_number)
            self.client.update_issue(epic_number, body=epic_body)
        else:
            epic_issue = self.client.create_issue(title=cfg.epic.title, body=epic_body, labels=cfg.epic.labels or ["epic"]) 
            epic_number = int(epic_issue["number"])

        # Cross-link via comments
        links: List[str] = []
        for child, num, created in created_children:
            if num == 0:
                continue
            child_link = f"#{num}"
            links.append(child_link)
            msg = f"Parent Epic: #{epic_number}\n\nThis issue is tracked in the epic checklist."
            # Best-effort comment; ignore failures to avoid aborting the whole run
            try:
                self.client.comment_on_issue(num, msg)
            except Exception as e:
                self._log.warning("Failed to comment on child #%s: %s", num, e)

        try:
            child_list = "\n".join([f"- {c.title} (#{n})" for (c, n, _cr) in created_children if n != 0])
            epic_comment = f"Linked child issues created/updated:\n\n{child_list}"
            self.client.comment_on_issue(epic_number, epic_comment)
        except Exception as e:
            self._log.warning("Failed to comment on epic #%s: %s", epic_number, e)

        return {
            "epic_number": epic_number,
            "children": {c.title: num for (c, num, _cr) in created_children},
        }
